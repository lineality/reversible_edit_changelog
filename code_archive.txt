
/// Finds all log files in a multi-byte log set
///
/// # Purpose
/// For a given base number, finds all associated log files including letter suffixes.
/// Returns them in LIFO order (highest letter first, bare number last).
///
/// # Arguments
/// * `log_dir` - Directory containing log files
/// * `base_number` - The base number for the log set
///
/// # Returns
/// * `ButtonResult<Vec<PathBuf>>` - Paths in LIFO order, or error if incomplete
///
/// # Expected Patterns
/// - 1-byte: just "10"
/// - 2-byte: "10.a", "10"
/// - 3-byte: "10.b", "10.a", "10"
/// - 4-byte: "10.c", "10.b", "10.a", "10"
///
/// # LIFO Order
/// Returns highest letter first: [10.c, 10.b, 10.a, 10]
///
/// # Validation
/// - Must have bare number file (no letter)
/// - Letters must be sequential from 'a' with no gaps
/// - Returns error if incomplete set detected
fn find_multibyte_log_set(log_dir: &Path, base_number: u128) -> ButtonResult<Vec<PathBuf>> {
    let mut log_files = Vec::with_capacity(MAX_UTF8_BYTES);

    // Check for bare number (required)
    let bare_path = log_dir.join(base_number.to_string());
    if !bare_path.exists() {
        return Err(ButtonError::IncompleteLogSet {
            base_number,
            found_logs: "missing base file",
        });
    }

    // Look for letter suffixes: a, b, c
    // Bounded loop: max 3 letters (MAX_UTF8_BYTES - 1)
    let mut found_letters = Vec::new();
    for i in 0..(MAX_UTF8_BYTES - 1) {
        let letter = LOG_LETTER_SEQUENCE[i];
        let letter_path = log_dir.join(format!("{}.{}", base_number, letter));

        if letter_path.exists() {
            found_letters.push((letter, letter_path));
        } else {
            // Stop at first missing letter
            break;
        }
    }

    // Validate sequence is continuous (no gaps)
    for (i, (letter, _)) in found_letters.iter().enumerate() {
        let expected_letter = LOG_LETTER_SEQUENCE[i];
        if *letter != expected_letter {
            return Err(ButtonError::IncompleteLogSet {
                base_number,
                found_logs: "non-sequential letters",
            });
        }
    }

    // Build result in LIFO order: highest letter first, bare number last
    // Reverse the found letters
    for (_letter, path) in found_letters.iter().rev() {
        log_files.push(path.clone());
    }

    // Add bare number last (comes out first in LIFO)
    log_files.push(bare_path);

    Ok(log_files)
}

/// Performs undo operation for next single-byte changelog in LIFO order
///
/// # Purpose
/// Main undo function for single-byte operations:
/// 1. Finds the next log file (highest numbered)
/// 2. Reads and parses the log file
/// 3. Executes the undo operation on the target file
/// 4. Removes the log file after successful undo
///
/// # Arguments
/// * `target_file` - File to perform undo on (absolute path)
/// * `log_dir` - Directory containing changelog files (absolute path)
///
/// # Returns
/// * `ButtonResult<()>` - Success or error
///
/// # Behavior on Error
/// - If log file is malformed: quarantine it and return error
/// - If file operation fails: leave log file in place, return error
/// - If undo succeeds: delete log file
///
/// # Examples
/// ```
/// // Undo the most recent single-byte edit
/// button_undo_single_byte_changelog(
///     &Path::new("/absolute/path/to/file.txt"),
///     &Path::new("/absolute/path/to/changelog_file")
/// )?;
/// ```
fn button_undo_single_byte_changelog(target_file: &Path, log_dir: &Path) -> ButtonResult<()> {
    // =================================================
    // Debug-Assert, Test-Assert, Production-Catch-Handle
    // =================================================

    debug_assert!(
        target_file.is_absolute(),
        "Target file must be absolute path"
    );

    #[cfg(test)]
    assert!(
        target_file.is_absolute(),
        "Target file must be absolute path"
    );

    if !target_file.is_absolute() {
        return Err(ButtonError::AssertionViolation {
            check: "Target file path must be absolute",
        });
    }

    debug_assert!(log_dir.is_absolute(), "Log directory must be absolute path");

    #[cfg(test)]
    assert!(log_dir.is_absolute(), "Log directory must be absolute path");

    if !log_dir.is_absolute() {
        return Err(ButtonError::AssertionViolation {
            check: "Log directory path must be absolute",
        });
    }

    // Step 1: Find next log file
    let log_file_path = find_next_lifo_log_file(log_dir)?;

    #[cfg(debug_assertions)]
    println!("Undoing log file: {}", log_file_path.display());

    // Step 2: Read and parse log file
    let log_entry = match read_log_file(&log_file_path) {
        Ok(entry) => entry,
        Err(e) => {
            // Log is malformed - quarantine it
            quarantine_bad_log(target_file, &log_file_path, "Failed to parse log file");
            return Err(e);
        }
    };

    // Step 3: Execute undo operation
    match execute_log_entry(target_file, &log_entry) {
        Ok(()) => {
            #[cfg(debug_assertions)]
            println!("Undo operation successful");

            // Step 4: Remove log file after successful undo
            if let Err(e) = fs::remove_file(&log_file_path) {
                #[cfg(debug_assertions)]
                eprintln!("Warning: Could not remove log file after undo: {}", e);

                // Non-fatal: log file remains but undo succeeded
                log_button_error(
                    target_file,
                    &format!("Could not remove log file after successful undo: {}", e),
                    Some("button_undo_single_byte_changelog"),
                );
            }

            Ok(())
        }
        Err(e) => {
            // Undo operation failed - leave log file in place
            #[cfg(debug_assertions)]
            eprintln!("Undo operation failed: {}", e);

            log_button_error(
                target_file,
                &format!("Undo operation failed: {}", e),
                Some("button_undo_single_byte_changelog"),
            );

            Err(e)
        }
    }
}
